package node

import (
	"sync"
	"testing"
	"time"

	"github.com/binance-chain/tss-lib/ecdsa/keygen"
)

func TestTSSPreParamsPool(t *testing.T) {
	poolSize := 5

	// Create new pool.
	tssPool := newTestPool(poolSize)

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid init length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	// Initial pool pump.
	tssPool.pumpPool()

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid start length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}

	// Get entry from pool.
	// We lock pumping here to verify if the entry gets removed from the pool
	// and lock new entry autogeneration.
	tssPool.pumpFuncMutex.Lock()

	result := tssPool.get()
	if result == nil {
		t.Errorf("result is nil")
	}

	result = tssPool.get()
	if result == nil {
		t.Errorf("result is nil")
	}

	if len(tssPool.params) != poolSize-2 {
		t.Errorf(
			"invalid after get length\nexpected: [%d]\nactual:   [%d]",
			poolSize-2,
			len(tssPool.params),
		)
	}

	// We unlock pumping here so new entry autogeneration can proceed.
	tssPool.pumpFuncMutex.Unlock()

	// Validate new entry has been autogenerated
	time.Sleep(100 * time.Millisecond)

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid end length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}
}

func TestTSSPreParamsPoolEmpty(t *testing.T) {
	poolSize := 1

	// Create new pool.
	tssPool := newTestPool(poolSize)

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid init length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	go func() {
		// Delay pumping so we have a chance to test if get function is waiting
		// for an entry.
		time.Sleep(100 * time.Millisecond)

		tssPool.pumpPool()
	}()

	// Get entry from pool.
	result := tssPool.get()
	if result == nil {
		t.Errorf("result is nil")
	}

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid after get length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	// Validate new entry has been autogenerated
	time.Sleep(100 * time.Millisecond)

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid end length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}
}

func TestTSSPreParamsPoolConcurrent(t *testing.T) {
	poolSize := 5

	// Create new pool.
	tssPool := newTestPool(poolSize)

	waitGroup := &sync.WaitGroup{}
	waitGroup.Add(2)

	go func() {
		if result := tssPool.get(); result == nil {
			t.Errorf("result is nil")
		}
		waitGroup.Done()
	}()
	go func() {
		if result := tssPool.get(); result == nil {
			t.Errorf("result is nil")
		}
		waitGroup.Done()
	}()

	time.Sleep(100 * time.Millisecond)

	go tssPool.pumpPool()

	waitGroup.Wait()

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid after get length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	// Validate new entries have been autogenerated
	time.Sleep(100 * time.Millisecond)

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid end length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}
}

func newTestPool(poolSize int) *tssPreParamsPool {
	return &tssPreParamsPool{
		pumpFuncMutex: &sync.Mutex{},
		paramsMutex:   sync.NewCond(&sync.Mutex{}),
		params:        []*keygen.LocalPreParams{},
		poolSize:      poolSize,
		new: func() (*keygen.LocalPreParams, error) {
			time.Sleep(10 * time.Millisecond)
			return &keygen.LocalPreParams{}, nil
		},
	}
}
