package tecdsa

import (
	"sync"
	"testing"
	"time"

	"github.com/binance-chain/tss-lib/ecdsa/keygen"
	"github.com/ipfs/go-log"
)

func TestTSSPreParamsPool(t *testing.T) {
	poolSize := 5

	// Create new pool.
	tssPool := newTestPool(poolSize)

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid init length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	// Initial pool pump.
	tssPool.pumpPool()

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid start length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}

	// Get entry from pool.
	// We lock pumping here to verify if the entry gets removed from the pool
	// and lock new entry autogeneration.
	tssPool.pumpFuncMutex.Lock()

	result := tssPool.Get()
	if result == nil {
		t.Errorf("result is nil")
	}

	result = tssPool.Get()
	if result == nil {
		t.Errorf("result is nil")
	}

	if len(tssPool.params) != poolSize-2 {
		t.Errorf(
			"invalid after get length\nexpected: [%d]\nactual:   [%d]",
			poolSize-2,
			len(tssPool.params),
		)
	}

	// We unlock pumping here so new entry autogeneration can proceed.
	tssPool.pumpFuncMutex.Unlock()

	// Validate new entry has been autogenerated
	time.Sleep(100 * time.Millisecond)

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid end length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}
}

func TestTSSPreParamsPoolEmpty(t *testing.T) {
	poolSize := 1

	// Create new pool.
	tssPool := newTestPool(poolSize)

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid init length\nexpected: [%d]\nactual:   [%d]",
			0,
			len(tssPool.params),
		)
	}

	// Get entry from pool.
	// We lock pumping here to verify if the entry gets removed from the pool
	// and lock new entry autogeneration.
	tssPool.pumpFuncMutex.Lock()

	result := tssPool.Get()
	if result != nil {
		t.Errorf("result is not nil")
	}

	if len(tssPool.params) != 0 {
		t.Errorf(
			"invalid after get length\nexpected: [%d]\nactual:   [%d]",
			0,
			0,
		)
	}

	// We unlock pumping here so new entry autogeneration can proceed.
	tssPool.pumpFuncMutex.Unlock()

	// Validate new entry has been autogenerated
	time.Sleep(100 * time.Millisecond)

	if len(tssPool.params) != poolSize {
		t.Errorf(
			"invalid end length\nexpected: [%d]\nactual:   [%d]",
			poolSize,
			len(tssPool.params),
		)
	}
}

func newTestPool(poolSize int) *TSSPreParamsPool {
	return &TSSPreParamsPool{
		pumpFuncMutex: &sync.Mutex{},
		paramsMutex:   &sync.Mutex{},
		params:        []*keygen.LocalPreParams{},
		poolSize:      poolSize,
		new: func() (*keygen.LocalPreParams, error) {
			return &keygen.LocalPreParams{}, nil
		},
	}
}
