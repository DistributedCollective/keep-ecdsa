const fs = require('fs');
const toml = require('toml');
const tomlify = require('tomlify-j0.4');
const concat = require('concat-stream');

// ETH host info
const ethHost = process.env.ETH_HOSTNAME;
const ethWsPort = process.env.ETH_WS_PORT;
const ethURL = process.env.ETH_URL || ethHost.replace('http://', 'ws://') + ':' + ethWsPort
const ethNetworkId = process.env.ETH_NETWORK_ID;

/*
Each <contract.json> file is sourced directly from the InitContainer.  Files are generated by
Truffle during contract migration and copied to the InitContainer image via Circle.
*/

const bondedECDSAKeepFactoryJsonFile = '/tmp/BondedECDSAKeepFactory.json';
const bondedECDSAKeepFactoryParsed = JSON.parse(fs.readFileSync(bondedECDSAKeepFactoryJsonFile));
const bondedECDSAKeepFactoryContractAddress = bondedECDSAKeepFactoryParsed.networks[ethNetworkId].address;

// TokenStaking
const keepBondingContractJsonFile = '/tmp/keepBonding.json';
const keepBondingContractParsed = JSON.parse(fs.readFileSync(keepBondingContractJsonFile));
const keepBondingContractAbi = keepBondingContractParsed.abi;
const keepBondingContractAddress = keepBondingContractParsed.networks[ethNetworkId].address;
const keepBondingContract = new web3.eth.Contract(keepBondingContractAbi, keepBondingContractAddress);

// TokenStaking
const tokenStakingContractJsonFile = '/tmp/TokenStaking.json';
const tokenStakingContractParsed = JSON.parse(fs.readFileSync(tokenStakingContractJsonFile));
const tokenStakingContractAbi = tokenStakingContractParsed.abi;
const tokenStakingContractAddress = tokenStakingContractParsed.networks[ethNetworkId].address;
const tokenStakingContract = new web3.eth.Contract(tokenStakingContractAbi, tokenStakingContractAddress);

// KeepToken
const keepTokenContractJsonFile = '/tmp/KeepToken.json';
const keepTokenContractParsed = JSON.parse(fs.readFileSync(keepTokenContractJsonFile));
const keepTokenContractAbi = keepTokenContractParsed.abi;
const keepTokenContractAddress = keepTokenContractParsed.networks[ethNetworkId].address;
const keepTokenContract = new web3.eth.Contract(keepTokenContractAbi, keepTokenContractAddress);

// Address of the external TBTCSystem contract which should be set for the InitContainer
// execution.
const tbtcSystemContractAddress = process.env.TBTC_SYSTEM_ADDRESS;

async function provisionKeepTecdsa() {

  try {

    console.log('###########  Provisioning keep-tecdsa! ###########');

    console.log(`\n<<<<<<<<<<<< Staking Operator Account ${operatorAddress} >>>>>>>>>>>>`);
    await stakeOperator(operatorAddress, contractOwnerAddress, authorizer);

    console.log('\n<<<<<<<<<<<< Creating keep-tecdsa Config File >>>>>>>>>>>>');
    await createKeepTecdsaConfig();

    console.log("\n########### keep-tecdsa Provisioning Complete! ###########");
  }
  catch (error) {
    console.error(error.message);
    throw error;
  }
};

async function isStaked(operatorAddress) {

  console.log('Checking if operator address is staked:');
  let stakedAmount = await tokenStakingContract.methods.balanceOf(operatorAddress).call();
  return stakedAmount != 0;
};

async function stakeOperator(operatorAddress, contractOwnerAddress, authorizer) {

  let staked = await isStaked(operatorAddress);

  /*
  We need to stake only in cases where an operator account is not already staked.  If the account
  is staked, or the client type is relay-requester we need to exit staking, albeit for different
  reasons.  In the case where the account is already staked, additional staking will fail.
  Clients of type relay-requester don't need to be staked to submit a request, they're acting more
  as a consumer of the network, rather than an operator.
  */
  if (staked === true) {
    console.log('Operator account already staked, exiting!');
    return;
  } else {
    console.log(`Staking 2000000 KEEP tokens on operator account ${operatorAddress}`);
  };

  let delegation = '0x' + Buffer.concat([
    Buffer.from(contractOwnerAddress.substr(2), 'hex'),
    Buffer.from(operatorAddress.substr(2), 'hex'),
    Buffer.from(authorizer.substr(2), 'hex')
  ]).toString('hex');

  await keepTokenContract.methods.approveAndCall(
    tokenStakingContract.address,
    formatAmount(20000000, 18),
    delegation).send({from: contractOwnerAddress})

  console.log(`Staked!`);
};

async function createKeepTecdsaConfig() {

  fs.createReadStream('/tmp/keep-tecdsa-template.toml', 'utf8').pipe(concat(function (data) {
    let parsedConfigFile = toml.parse(data);

    parsedConfigFile.ethereum.URL = ethURL;

    parsedConfigFile.ethereum.account.KeyFile = [
      process.env.KEEP_TECDSA_ETH_KEYFILE_1,
      process.env.KEEP_TECDSA_ETH_KEYFILE_2,
      process.env.KEEP_TECDSA_ETH_KEYFILE_3
    ]
    parsedConfigFile.ethereum.ContractAddresses.BondedECDSAKeepFactory = bondedECDSAKeepFactoryContractAddress;

    parsedConfigFile.SanctionedApplications.Addresses = [tbtcSystemContractAddress]

    parsedConfigFile.Storage.DataDir = process.env.KEEP_DATA_DIR;

    fs.writeFile('/mnt/keep-tecdsa/config/keep-tecdsa-config.toml', tomlify.toToml(parsedConfigFile), (error) => {
      if (error) throw error;
    });
  }));

  console.log("keep-tecdsa config written to /mnt/keep-tecdsa/config/keep-tecdsa-config.toml");
};

provisionKeepTecdsa().catch(error => {
  console.error(error);
  process.exit(1);
});
